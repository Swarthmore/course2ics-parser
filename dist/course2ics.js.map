{"version":3,"file":"course2ics.js","sources":["../src/index.js"],"sourcesContent":["#!/usr/bin/env node\r\n\r\nconst { RRule } = require('rrule')\r\nconst yargs = require('yargs/yargs')\r\nconst { hideBin } = require('yargs/helpers')\r\nconst fs = require('fs').promises\r\nconst argv = yargs(hideBin(process.argv)).argv\r\nconst Papa = require('papaparse')\r\nconst ics = require('ics')\r\nconst moment = require('moment')\r\nconst { validateArgs, validateRow } = require('./validators')\r\nconst { daysFromString, timeDiff, firstDayAfterDate } = require('./helpers')\r\n\r\n// See: https://momentjs.com/docs/#/use-it/node-js/\r\nmoment().format()\r\n\r\n// See: https://github.com/moment/moment/issues/3488\r\nmoment.suppressDeprecationWarnings = true;\r\n\r\n// If --docs was passed as an argument, show the documentation, then end the process\r\nif (argv.docs) {\r\n  console.log(`\r\n        NAME\r\n            course2ics\r\n            \r\n        DESCRIPTION\r\n            Generate an iCalendar (.ics) files from a csv.\r\n            \r\n            The following options are available:\r\n            \r\n            --input     REQUIRED. The path to the input csv. \r\n            \r\n            --from      REQUIRED. The starting date. Must be in ISO format YYYY-MM-DD. \r\n            \r\n            --to        REQUIRED. The ending date. Must be in ISO format YYYY-MM-DD.\r\n\r\n            --verbose   Run with verbose output.\r\n        \r\n            --docs      View the help docs (You're reading them! ðŸš€)\r\n        \r\n        \r\n        CSV FORMAT\r\n            The input csv MUST be in the following format\r\n            \r\n            TITLE, SUBJ, CRSE, INSTR1, INSTR2, INSTR1_EMAIL, INSTR2_EMAIL, DAYS1, DAYS2, TIME1, TIME2\r\n\r\n            TITLE           The title of the event\r\n            SUBJ            The course subject\r\n            CRSE            The course number\r\n            INSTR1          The full name of the primary instructor, in the format Last, First\r\n            INSTR2          The full name of the secondary instructor, in the format Last, First\r\n                            This field may also be blank\r\n            INSTR1_EMAIL    The email address of the primary instructor\r\n            INSTR2_EMAIL    The email address of the secondary instructor\r\n            DAYS1           A comma delimited set of days when the event happens.\r\n                            M = Monday, T = Tuesday, W = Wednesday, Th = Thursday, F = Friday, S = Saturday, Su = Sunday\r\n                            Ex: M,T,W,Th,F\r\n            DAYS2           A comma delimited set of days when the event happens. This second set is optional.\r\n            TIME1           The time for when the events defined in DAYS1 occur, in the format of HH-DD (24 hours)\r\n            TIME2           The time for when the events defined in DAYS2 occur, in the format of HH-DD (24 hours)\r\n            \r\n        EXAMPLE USAGE\r\n            node src/index.js --input=/path/to/input.csv --from=2020-01-01 --to=2020-03-01 \r\n        \r\n        CAVEATS\r\n            Files will be saved to PROJECT_ROOT/output. This means the output folder must be created before usage.\r\n            \r\n    `)\r\n\r\n  process.exit()\r\n}\r\n\r\n// Output a debug message. This will only work if --verbose is passed to the script\r\nconst debugMessage = (message) => {\r\n  if (!argv.verbose) return\r\n  console.debug(\r\n    typeof message === 'string' ? message : JSON.stringify(message)\r\n  )\r\n}\r\n\r\n/**\r\n * The main function\r\n * @param argv - Arguments - See docs\r\n * @returns {Promise<void>}\r\n */\r\nconst main = async (argv) => {\r\n\r\n  // Validate the arguments\r\n  validateArgs(argv)\r\n\r\n  // Create the file path\r\n  const fp = `${__dirname}/${argv.input}`\r\n\r\n  // Read the CSV\r\n  const file = await fs.readFile(fp, 'utf8')\r\n\r\n  // Handle the processing of a single row of data\r\n  const processRow = async (row) => {\r\n\r\n    // validate the row\r\n    const isValid = validateRow(row)\r\n\r\n    // if the row is not valid, return out of the function \r\n    if (!isValid) {\r\n      return\r\n    }\r\n\r\n    // destructure everything out of the row\r\n    const [title, subject, course, instr1, instr2, email1, email2, days1, days2, time1, time2] = row\r\n\r\n    /**\r\n     * Creates a single ics file\r\n     * @param instr\r\n     * @param email\r\n     * @param days\r\n     * @param times\r\n     * @returns {Promise<*>}\r\n     */\r\n    const createAndWriteEvent = async (instr, email, days, times) => {\r\n      try {\r\n\r\n        const spl = daysFromString(days)\r\n\r\n        const rrule = new RRule({\r\n          freq: RRule.WEEKLY,\r\n          byweekday: spl.map(day => {\r\n            switch (day) {\r\n              case 'U':\r\n                return RRule.SU\r\n              case 'M':\r\n                return RRule.MO\r\n              case 'T':\r\n                return RRule.TU\r\n              case 'W':\r\n                return RRule.WE\r\n              case 'R':\r\n                return RRule.TH\r\n              case 'F':\r\n                return RRule.FR\r\n              case 'S':\r\n                return RRule.SA\r\n              default:\r\n                break\r\n            }\r\n          })\r\n            .filter(day => day),\r\n          until: new Date(argv.to)\r\n        })\r\n\r\n        const firstDay = firstDayAfterDate(argv.from, days, times, moment)\r\n\r\n        if (!firstDay) return\r\n\r\n        const start = firstDay.format('YYYY-M-D-H-m').split(\"-\")\r\n\r\n        const duration = timeDiff(times)\r\n\r\n        // rrule.toString() will include the beginning RRULE:\r\n        // This is not needed with the ics library\r\n        // This line of code splits the returned rrule string at RRULE: and assigns the\r\n        // second part (the part we need) to a variable.\r\n        const [, recurrenceRule] = rrule.toString().split('RRULE:')\r\n\r\n        const eventTitle = `${subject}${course}`\r\n\r\n        const event = {\r\n          // Start is in the format [year, month, day, hour, min]\r\n          start: start,\r\n          duration: duration,\r\n          recurrenceRule: recurrenceRule,\r\n          title: eventTitle,\r\n          description: title,\r\n          status: 'CONFIRMED',\r\n          organizer: {\r\n            name: instr,\r\n            email: email\r\n          }\r\n        }\r\n\r\n        const fp = ics.createEvent(event, async (err, val) => {\r\n\r\n          if (err) {\r\n            throw err\r\n          }\r\n\r\n          // Set the file name\r\n          const fn = start.join('-') + '_' + days.replace(/,/g, '') + '_' + times.replace(/[:-\\s]/g, '') + '_' + subject + '-' + course + '.ics'\r\n\r\n          // Set the filepath\r\n          const fp = `output/${fn}`\r\n\r\n          // Save the file\r\n          await fs.writeFile(fp, val)\r\n\r\n          // Resolve promise with filepath\r\n          return fp\r\n\r\n        })\r\n\r\n        return fp\r\n\r\n      } catch (e) {\r\n        // Reject promise with error\r\n        throw e\r\n      }\r\n    }\r\n\r\n    // Create the ics file for the primary event\r\n    const fp1 = await createAndWriteEvent(instr1, email1, days1, time1)\r\n    debugMessage(`Writing event for ${instr1, email1, days1, time1}`)\r\n    debugMessage('Wrote new ics to disk', fp1)\r\n\r\n    // If days2 and time2 are provided, create the ics for that event\r\n    if (days2 && time2) {\r\n      const fp2 = await createAndWriteEvent(instr1, email1, days2, time2)\r\n      debugMessage(`Writing event for ${instr1, email1, days2, time2}`)\r\n      debugMessage('Wrote new ics to disk', fp2)\r\n    }\r\n\r\n  }\r\n\r\n  // Handle the processed results\r\n  const handleResults = (results) => {\r\n    const rows = results.data.slice(1)\r\n    // Process the rows\r\n    rows.forEach(async row => {\r\n      await processRow(row)\r\n    })\r\n  }\r\n\r\n  // Use the papa to parse the file ðŸ•\r\n  Papa.parse(file, {\r\n    complete: results => handleResults(results)\r\n  })\r\n\r\n}\r\n\r\n// Run the script\r\n(async () => {\r\n  await main(argv)\r\n  return 0\r\n})()"],"names":["RRule","require","yargs","hideBin","fs","promises","argv","process","Papa","ics","moment","validateArgs","validateRow","daysFromString","timeDiff","firstDayAfterDate","format","suppressDeprecationWarnings","docs","console","log","exit","debugMessage","message","verbose","debug","JSON","stringify","fp","__dirname","input","readFile","file","parse","complete","results","data","slice","forEach","row","title","subject","course","instr1","email1","days2","time1","time2","createAndWriteEvent","instr","email","days","times","spl","rrule","freq","WEEKLY","byweekday","map","day","SU","MO","TU","WE","TH","FR","SA","filter","until","Date","to","firstDay","from","start","split","duration","toString","createEvent","recurrenceRule","description","status","organizer","name","err","val","join","replace","writeFile","e","fp1","fp2","processRow","handleResults","main"],"mappings":";IAEQA,EAAUC,QAAQ,SAAlBD,MACFE,EAAQD,QAAQ,eACdE,EAAYF,QAAQ,iBAApBE,QACFC,EAAKH,QAAQ,MAAMI,SACnBC,EAAOJ,EAAMC,EAAQI,QAAQD,OAAOA,KACpCE,EAAOP,QAAQ,aACfQ,EAAMR,QAAQ,OACdS,EAAST,QAAQ,YACeA,QAAQ,gBAAtCU,IAAAA,aAAcC,IAAAA,cACkCX,QAAQ,aAAxDY,IAAAA,eAAgBC,IAAAA,SAAUC,IAAAA,kBAGlCL,IAASM,SAGTN,EAAOO,6BAA8B,EAGjCX,EAAKY,OACPC,QAAQC,4tEAgDRb,QAAQc,QAIV,IAAMC,EAAe,SAACC,GACfjB,EAAKkB,SACVL,QAAQM,MACa,iBAAZF,EAAuBA,EAAUG,KAAKC,UAAUJ,MAkK3D,wCAzJoBjB,OAGlBK,EAAaL,GAGb,IAAMsB,EAAQC,cAAavB,EAAKwB,MANL,uBASR1B,EAAG2B,SAASH,EAAI,uBAA7BI,GAyINxB,EAAKyB,MAAMD,EAAM,CACfE,SAAU,SAAAC,UAVU,SAACA,GACRA,EAAQC,KAAKC,MAAM,GAE3BC,iBAAcC,uCAhIKA,OAMxB,IAHgB3B,EAAY2B,GAI1B,yBAP8B,IAWzBC,EAAsFD,KAA/EE,EAA+EF,KAAtEG,EAAsEH,KAA9DI,EAA8DJ,KAA9CK,EAA8CL,KAAvBM,EAAuBN,KAAhBO,EAAgBP,KAATQ,EAASR,MAUvFS,WAA6BC,EAAOC,EAAOC,EAAMC,OACrD,IAEE,IAAMC,EAAMxC,EAAesC,GAErBG,EAAQ,IAAItD,EAAM,CACtBuD,KAAMvD,EAAMwD,OACZC,UAAWJ,EAAIK,IAAI,SAAAC,GACjB,OAAQA,GACN,IAAK,IACH,OAAO3D,EAAM4D,GACf,IAAK,IACH,OAAO5D,EAAM6D,GACf,IAAK,IACH,OAAO7D,EAAM8D,GACf,IAAK,IACH,OAAO9D,EAAM+D,GACf,IAAK,IACH,OAAO/D,EAAMgE,GACf,IAAK,IACH,OAAOhE,EAAMiE,GACf,IAAK,IACH,OAAOjE,EAAMkE,MAKhBC,OAAO,SAAAR,UAAOA,IACjBS,MAAO,IAAIC,KAAK/D,EAAKgE,MAGjBC,EAAWxD,EAAkBT,EAAKkE,KAAMrB,EAAMC,EAAO1C,GAE3D,IAAK6D,EAAU,yBAEf,IAAME,EAAQF,EAASvD,OAAO,gBAAgB0D,MAAM,KAE9CC,EAAW7D,EAASsC,KAMCE,EAAMsB,WAAWF,MAAM,UAkB5C9C,EAAKnB,EAAIoE,YAdD,CAEZJ,MAAOA,EACPE,SAAUA,EACVG,oBACAtC,SAPoBC,EAAUC,EAQ9BqC,YAAavC,EACbwC,OAAQ,YACRC,UAAW,CACTC,KAAMjC,EACNC,MAAOA,aAI8BiC,EAAKC,OAE5C,GAAID,EACF,MAAMA,EAIR,IAGMvD,YAHK6C,EAAMY,KAAK,KAAO,IAAMlC,EAAKmC,QAAQ,KAAM,IAAM,IAAMlC,EAAMkC,QAAQ,UAAW,IAAM,IAAM7C,EAAU,IAAMC,EAAS,OAP5E,uBAa9CtC,EAAGmF,UAAU3D,EAAIwD,oBAGvB,OAAOxD,IAhBE,qCAoBX,uBAAOA,GAEP,MAAO4D,GAEP,MAAMA,GArFe,oCArBO,uBA+GdxC,EAAoBL,EAAQC,EApG+CL,KAoGhCO,kBAAvD2C,GACNnE,uBAAyDwB,GACzDxB,EAAa,yBAjHmB,oBAoH5BuB,GAASE,yBACOC,EAAoBL,EAAQC,EAAQC,EAAOE,kBAAvD2C,GACNpE,uBAAyDyB,GACzDzB,EAAa,yEAvHD,mCAiINqE,CAAWpD,uBADnB,qCAOqBqD,CAAczD,QAnJ7B,mCA0JF0D,CAAKvF,oBACX,WAFF,4BAAA"}