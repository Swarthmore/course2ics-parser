{"version":3,"file":"course2ics-parser.module.js","sources":["../src/index.js"],"sourcesContent":["const { RRule } = require('rrule')\r\nconst fs = require('fs').promises\r\nconst Papa = require('papaparse')\r\nconst ics = require('ics')\r\nconst moment = require('moment')\r\nconst { validateArgs, validateRow } = require('./validators')\r\nconst { daysFromString, timeDiff, firstDayAfterDate, flipName } = require('./helpers')\r\nconst path = require('path')\r\n\r\n// See: https://momentjs.com/docs/#/use-it/node-js/\r\nmoment().format()\r\n\r\n// See: https://github.com/moment/moment/issues/3488\r\nmoment.suppressDeprecationWarnings = true;\r\n\r\n/**\r\n * Parses a csv and creates an ics file for each row. The generated ics will contain events recurring weekly from\r\n * the given fromDate until the given toDate.\r\n *  \r\n * @param {Object}  argv - The function arguments\r\n * @param {boolean} argv.verbose - Runs the function in verbose mode\r\n * @param {string}  argv.outputDir - The directory to save the files to. This directory must exist.\r\n * @param {string}  argv.inputFile - The input csv\r\n * @param {string}  argv.toDate - The starting date\r\n * @param {string}  argv.fromDate - The end date\r\n * \r\n * @returns {Promise<void>}\r\n */\r\n\r\nasync function parse(argv) {\r\n\r\n  /**\r\n   * Output a debug message. This will only work if --verbose is passed to the script\r\n   * @param {string} message - The message to output \r\n   * @returns void\r\n   */\r\n  const debugMessage = (message) => {\r\n    if (!argv.verbose) return\r\n    console.debug(\r\n      typeof message === 'string' ? message : JSON.stringify(message)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Reads a CSV file from disk\r\n   * @param {string} filepath - The path to the csv\r\n   * @returns {Promise<string>} - The contents of the file\r\n   */\r\n  async function readCsv(filepath) {\r\n    try {\r\n      return await fs.readFile(filepath, 'utf8')\r\n    } catch (e) {\r\n      return e\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates an ics event\r\n   * \r\n   * @param {Object} args - The function arguments\r\n   * @param {string} args.subject\r\n   * @param {string} args.course\r\n   * @param {string} args.section\r\n   * @param {string} args.instructor\r\n   * @param {string} args.email\r\n   * @param {string} args.days\r\n   * @param {string} args.times\r\n   * @param {string} args.fromDate\r\n   * @param {string} args.toDate \r\n   * \r\n   * @returns {Promise<string>} - Returns a promise that resolves with the ICS event\r\n   */\r\n  async function createIcsEvent({ title, subject, course, section, instructor, email, days, times, fromDate, toDate }) {\r\n\r\n    const daysArr = daysFromString(days)\r\n\r\n    const rrule = new RRule({\r\n      freq: RRule.WEEKLY,\r\n      byweekday: daysArr.map(day => {\r\n        switch (day) {\r\n          case 'U':\r\n            return RRule.SU\r\n          case 'M':\r\n            return RRule.MO\r\n          case 'T':\r\n            return RRule.TU\r\n          case 'W':\r\n            return RRule.WE\r\n          case 'R':\r\n            return RRule.TH\r\n          case 'F':\r\n            return RRule.FR\r\n          case 'S':\r\n            return RRule.SA\r\n          default:\r\n            break\r\n        }\r\n      }).filter(day => day),\r\n      until: new Date(toDate)\r\n    })\r\n\r\n    const firstDay = firstDayAfterDate(fromDate, days, times, moment)\r\n\r\n    const start = firstDay.format('YYYY-M-D-H-m').split(\"-\")\r\n\r\n    const duration = timeDiff(times)\r\n\r\n    // rrule.toString() will include the beginning RRULE:\r\n    // This is not needed with the ics library\r\n    // This line of code splits the returned rrule string at RRULE: and assigns the\r\n    // second part (the part we need) to a variable.\r\n    const [, recurrenceRule] = rrule.toString().split('RRULE:')\r\n\r\n    const eventTitle = `${subject} ${course} ${section}`\r\n\r\n    const event = {\r\n      // Start is in the format [year, month, day, hour, min]\r\n      start: start,\r\n      duration: duration,\r\n      recurrenceRule: recurrenceRule,\r\n      title: eventTitle,\r\n      description: title,\r\n      status: 'CONFIRMED',\r\n      organizer: {\r\n        name: flipName(instructor),\r\n        email: email\r\n      }\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      ics.createEvent(event, (err, val) => {\r\n        if (err) reject(err)\r\n        resolve(val)\r\n      })\r\n    })\r\n\r\n  }\r\n\r\n  /**\r\n   * Writes an ics file to disk\r\n   * @param {string} icsData - The generated ics data \r\n   * @param {string} fileName - The full file name to save\r\n   * @returns {Promise<string>} - Returns a promise that will resolve with the created filename\r\n   */\r\n  async function writeIcsToDisk(icsData, fileName) {\r\n    try {\r\n      await fs.writeFile(fileName, icsData)\r\n      return fileName\r\n    } catch (e) {\r\n      return e\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Runs the parser\r\n   * @return {Promise<{ title: string; subject: string; course: string; section: string; instructor: string; email: string; days: string; times: string; fromDate: any; toDate: any; filename: string; }[]>} - Returns a promise that resolves with the created files\r\n   */\r\n  async function runParser() {\r\n\r\n    return new Promise((resolve, reject) => {\r\n\r\n      Papa.parse(csv, {\r\n        complete: async results => {\r\n\r\n          // keep track of the created files, along with the source row\r\n          let created = []\r\n\r\n          // Get the rows from papa parse\r\n          const rows = results.data.slice(1)\r\n\r\n          if (rows.length === 0) {\r\n            reject('No rows could be parsed from csv')\r\n          }\r\n\r\n          let i = 0\r\n\r\n          for await (let r of rows) {\r\n\r\n            try {\r\n              debugMessage('-------------------------------------------')\r\n              debugMessage(`Processing row ${i}`)\r\n              debugMessage(r)\r\n\r\n              // validate the row\r\n              const row = await validateRow(r)\r\n\r\n              const [title, subject, course, instr1, instr2, email1, email2, days1, days2, time1, time2, section] = row\r\n\r\n              const ics1 = await createIcsEvent({\r\n                title,\r\n                subject,\r\n                course,\r\n                section,\r\n                instructor: instr1,\r\n                email: email1,\r\n                days: days1,\r\n                times: time1,\r\n                fromDate: args.fromDate,\r\n                toDate: args.toDate\r\n              })\r\n\r\n              // Set the file name\r\n              const fn1 = `${title.replace(/[/\\\\?%*:|\"<>\\s]/g, '-')}__${section}_${days1.replace(/,/g, '')}__${time1.replace(/[:-\\s]/g, '')}`\r\n              const ext = '.ics'\r\n\r\n              const fp1 = path.join(outputDir, fn1 + ext)\r\n              const f1 = await writeIcsToDisk(ics1, fp1)\r\n              debugMessage('Created' + ' ' + f1)\r\n\r\n              created.push({\r\n                title,\r\n                subject,\r\n                course,\r\n                section,\r\n                instructor: instr1,\r\n                email: email1,\r\n                days: days1,\r\n                times: time1,\r\n                fromDate: args.fromDate,\r\n                toDate: args.toDate,\r\n                filename: f1\r\n              })\r\n\r\n              if (days2 && time2) {\r\n                const ics2 = await createIcsEvent({\r\n                  title,\r\n                  subject,\r\n                  course,\r\n                  section,\r\n                  instructor: instr1,\r\n                  email: email1,\r\n                  days: days2,\r\n                  times: time2,\r\n                  fromDate: args.fromDate,\r\n                  toDate: args.toDate\r\n                })\r\n                const fn2 = `${title.replace(/[/\\\\?%*:|\"<>\\s]/g, '-')}__${section}_${days2.replace(/,/g, '')}__${time2.replace(/[:-\\s]/g, '')}`\r\n                const fp2 = path.join(outputDir, fn2 + ext)\r\n                const f2 = await writeIcsToDisk(ics2, fp2)\r\n                debugMessage('Created' + ' ' + f2)\r\n\r\n                created.push({\r\n                  title,\r\n                  subject,\r\n                  course,\r\n                  section,\r\n                  instructor: instr1,\r\n                  email: email1,\r\n                  days: days2,\r\n                  times: time2,\r\n                  fromDate: args.fromDate,\r\n                  toDate: args.toDate,\r\n                  filename: f2\r\n                })\r\n              }\r\n\r\n            } catch (e) {\r\n              debugMessage(e)\r\n            } finally {\r\n              i++\r\n            }\r\n\r\n          }\r\n\r\n          // once everything is done processing, create the index json file\r\n          await fs.writeFile(outputDir + '/' + 'index.json', JSON.stringify(created), 'utf8')\r\n\r\n          debugMessage('Done!')\r\n\r\n          resolve(created)\r\n\r\n        }\r\n      })\r\n\r\n    })\r\n\r\n  }\r\n\r\n  // Validate the arguments\r\n  const args = await validateArgs(argv)\r\n\r\n  // Set the output directory based on the arguments provided\r\n  const outputDir = path.normalize(args.outputDir)\r\n\r\n  // Read the CSV\r\n  const csv = await readCsv(path.normalize(args.inputFile))\r\n\r\n  return runParser()\r\n\r\n}\r\n\r\nmodule.exports = { parse }"],"names":["RRule","require","fs","promises","Papa","ics","moment","validateArgs","validateRow","daysFromString","timeDiff","firstDayAfterDate","flipName","path","format","suppressDeprecationWarnings","module","exports","parse","async","argv","debugMessage","message","verbose","console","debug","JSON","stringify","createIcsEvent","title","subject","course","section","instructor","email","days","times","fromDate","toDate","daysArr","rrule","freq","WEEKLY","byweekday","map","day","SU","MO","TU","WE","TH","FR","SA","filter","until","Date","start","split","duration","recurrenceRule","toString","event","description","status","organizer","name","Promise","resolve","reject","createEvent","err","val","writeIcsToDisk","icsData","fileName","writeFile","e","args","outputDir","normalize","csv","filepath","readFile","readCsv","inputFile","complete","created","rows","results","data","slice","length","i","r","row","instr1","instr2","email1","email2","days1","days2","time1","time2","ics1","fn1","replace","ext","fp1","join","f1","push","filename","ics2","fn2","fp2","f2","runParser"],"mappings":"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"}